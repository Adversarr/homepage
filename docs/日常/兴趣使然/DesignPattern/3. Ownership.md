---
share: true
tags:
  - DesignPattern
  - Cpp
---


#DesignPattern , #Cpp 

# 内存所有权

内存所有权与资源所有权有着紧密的联系：

1. 内存是一种资源，它虽然不是程序可以管理的唯一资源，但也是迄今为止最常用的资源。
2. C++管理资源的方式是让对象拥有它。因此，管理资源的问题简化为管理对象。

内存所有权不仅仅是获得更多的内存。管理内存如果不的当，就会引发泄漏、内存计算错误、丢失资源等问题。

部分对象仅仅是为了获取别处传过来的资源，并不关心资源从谁那儿拿到，使用move去转移内存所有权：

```cpp
class A {
public:
    A(std::vector<int>&& v): v_(std::move(v)) {} // 转移入参所有权

private:
    std::vector<int> v_; // 类中拥有的对象
};
```

## 不好的所有权设计

### Example: Pointer and factories

考虑以下例子的实现：

```cpp
Widget* w = MakeWidget();
```

MakeWidget方法设计可以直观的看出谁拥有资源吗？是否w可以被删除，如果可以，该如何被删除？

Factory拥有它所创建出来的对象的所有权吗？如果删除了Factory对象，创建出的对象是否会被删除？这些操作与调用者的期望是否一致？

如果Factory知道创建出来的对象，并且会在某些时刻删除这些对象，就会引起内存泄漏，甚至对象拥有其他未知资源。

### Another Example： Shared Ptr

考虑如下代码：

```cpp
void Double(std::shared_ptr<std::vector<int>> v) {};

std::shared_ptr<std::vector<int>> v(new std::vector<int>{0, 1, 2, 3});
Double(v);

```

Double方法的作用仅仅是对vector的值进行修改，这里却传入了一个shared的智能指针，获得了指针的所有权，这不是一个良好的设计。

## 无所有权

第一种常见的所有权类型是无所有权。绝大多数代码不需要对内存进行分配、释放、构造或删除。往往对象生成或删除的时候才会涉及到内存操作，很多时候我们仅仅是操作这个对象而不对这个对象的内存进行管理，这时候应该使用原始的指针或者引用（如上面的Double方法）。

> [!summary] 
> 
> **如果一个方法无需对对象内存进行管理，那么应该使用原始指针或引用。**

另一个问题是：用指针好还是用引用好。就语法而言，引用其实就是一个必须经过初始化的非空指针。因此，不接受空指针的方法就要使用引用作为入参。C++核心库提供了一种非空指针的表示：not_null。


## 独占所有权

第二种常见的所有权类型是专有所有权。

> 独占的意思就是不分享，所有权可以转移，转移后所有权仍然是独占的。

所有的局部变量（栈上变量）都表示独占所有权。请注意，在这种情况下的所有权并不表示其他人不会修改该对象。

### 所有权转移

工厂模式是最常见的，发生所有权转移的地方。

```cpp
class Factory {
  std::unique_ptr<int> build() const noexcept {
    ...
    return std::move(ptr);
  }
};
```

## 共享所有权

**共享指针优点：**

共享拥有权的对象一般比限定作用域的对象生存更久。在并发中，使用共享指针可以保证在执行期间保护该对象不被其他线程删除。

**共享指针缺点：**

1. 循环依赖：如果两个共享指针对象相互指向对象，则整个对象将会无限循环使用。C++标准库提供了std::weak_ptr来解决循环依赖的问题。shared_ptr与weak_ptr结合使用就可以避免循环引用问题。
2. 共享指针的性能比原生指针效率更低，而一个独占指针与原生指针效率基本一致。当创建共享指针时，用于实现引用计数的额外内存将会被分配。
